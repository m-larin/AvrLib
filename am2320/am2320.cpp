#include <avr/io.h>
#include <util/delay.h>
#include "am2320.h"


Am2320::Am2320(volatile uint8_t * sensorPort, volatile uint8_t * sensorPin, volatile uint8_t * sensorDdr, unsigned char sensorBit){
	_sensorPort = *sensorPort;
	_sensorPin = *sensorPin;
	_sensorDdr = *sensorDdr;
	_sensorBit = sensorBit;
}

/*************************************************************************
1. Контроллер переводит свой пин в режим выхода - как минимум на 800 микросекунд переводит его в LOW, затем переключается на вход;
2. Через 30 мкс AM2320 отвечает подтверждением, также сначала переводя шину в LOW на 80 мкс, а затем в HIGH на 80 мкс;
3. DHT11 начинает побитную передачу информации, каждый бит начинается с уровня LOW в течение 50 мкс, и затем HIGH разной продолжительности: если 26-28 мкс, то это ноль, если же 70 мкс - единица;
4. По окончании передачи 40 бит информации DHT11 "на прощание" еще раз переводит шину в LOW на 50 мкс и освобождает ее.
Если в программе имеются прерывания,то не забывайте их отлючать перед чтением датчика     */
/************************************************************************/
unsigned char Am2320::read(unsigned char * data)
{
	data[0] = data[1] = data[2] = data[3] = data[4] = 0;

	_sensorDdr |=_BV(_sensorBit); //пин на выход
	_sensorPort &= ~(_BV(_sensorBit)); //на выходе 0
	_delay_ms(1); //спим 1 мс
	_sensorPort |= (_BV(_sensorBit)); //Отпускаем линию
	_sensorDdr &= ~(_BV(_sensorBit));  //Порт на вход

	//Ждем ответа дат+чика - 0 на шине
	unsigned char count = 0;
	while (_sensorPin & (_BV(_sensorBit))){
		//Датчик должен ответить через 20-40 мкс, но мы ждем 200 мкс, для надежности
		//Пока на шине 1 крутимся в цикле, но не более 200 мкс, если вышли за 200 мкс то датчик уже не ответит
		_delay_us(5);
		count++;
		if (count > 40){
			return 0;
		}
	}
	
	//Датчик ответил, теперь ждем пока он отпустить шину через 80 мкс
	//Крутимся в цикле пока на шине 0
	while (!(_sensorPin&(_BV(_sensorBit))));

	//теперь ждем пока начнется передача данных
	//Крутимся в цикле пока на шине 1
	while (_sensorPin&(_BV(_sensorBit)));
	
	//Данные начались, принимаем 40 бит - 5 байт
	//i-номер байта
	for(int i=0; i<5; i++){
		//j-номер бита, так как биты идут задом наперед от старшего разряда к младшему цикл строим на уменьшение j от 7 до 0
		for(int j=7; j>=0; j--){
			//замеряем на сколько датчик прижал шину к земле, должен на 50 мкс но в условиях без кварца на время надеятся не будем
			//замеряем количество циклов по 1 мкс, при последующем передаче 0 будет меньше а при передаче 1 больше этих циклов
			//все это делаем чтобы исключить влияние температуры на частоту контроллера без кварца
			int preDataCount = 0;
			while (!(_sensorPin&(_BV(_sensorBit)))){
				_delay_us(1);
				preDataCount++;
			}
			
			//Начался бит данных
			int dataCount = 0;
			while (_sensorPin&(_BV(_sensorBit))){
				_delay_us(1);
				dataCount++;
			}
			
			//И самое интересное, если логический ноль на шине был короче чем логическая еденица то приняли байт = 1 иначе 0
			//Пишем только еденицы, так как в начале функции во все байты данных прописали нули
			if (preDataCount < dataCount){
				//Считали 1
				data[i] |= _BV(j);
			}
		}
	}
	
	//Проверяем контрольную сумму и что она не нулевая
	unsigned char checkSumm = data[0] + data[1] + data[2] + data[3];
	if (checkSumm == data[4] && data[4]>0)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
